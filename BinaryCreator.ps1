#Requires -Version 5.1
<#
.SYNOPSIS
    Downloads HIBP NTLM password hashes and compresses them to a binary file.

.DESCRIPTION
    1. Reads paths from config.psd1 (generated by PrepareEnv.ps1).
    2. Downloads all NTLM hashes with haveibeenpwned-downloader (64 threads,
       overwrite enabled).  Output streamed live to console + log.
    3. Compresses the resulting text file to a packed binary with PsiRepacker,
       showing a live progress spinner with elapsed time and growing file size.
    4. Final binary is saved as  hibpntlmhashes<ddMMyy>.bin  in output\bin\.

.EXAMPLE
    .\BinaryCreator.ps1

.EXAMPLE
    .\BinaryCreator.ps1 -SkipDownload   # skip download if hash file already present

.EXAMPLE
    .\BinaryCreator.ps1 -Parallelism 32   # override download thread count
#>

[CmdletBinding()]
param(
    [int]   $Parallelism = 64,
    [switch]$NoOverwrite,     # pass to skip -o flag for the downloader
    [switch]$SkipDownload     # skip download if hash file already exists
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# ─────────────────────────────────────────────────────────────────────────────
#  Load config
# ─────────────────────────────────────────────────────────────────────────────
$configPath = Join-Path $PSScriptRoot 'config.psd1'

if (-not (Test-Path $configPath)) {
    Write-Host '[WARN]  config.psd1 not found – running PrepareEnv.ps1 first...' -ForegroundColor Yellow
    $prepareScript = Join-Path $PSScriptRoot 'PrepareEnv.ps1'
    if (-not (Test-Path $prepareScript)) {
        Write-Host "[ERROR] PrepareEnv.ps1 not found at: $prepareScript" -ForegroundColor Red
        exit 1
    }
    & $prepareScript
    if ($LASTEXITCODE -ne 0) {
        Write-Host '[ERROR] PrepareEnv.ps1 failed. Cannot continue.' -ForegroundColor Red
        exit 1
    }
    if (-not (Test-Path $configPath)) {
        Write-Host '[ERROR] PrepareEnv.ps1 completed but config.psd1 was not created.' -ForegroundColor Red
        exit 1
    }
    Write-Host '[SUCCESS] Environment ready – continuing with BinaryCreator.' -ForegroundColor Green
}

$cfg = Import-PowerShellDataFile -Path $configPath

$HashesDir     = $cfg.HashesDir
$BinDir        = $cfg.BinDir
$LogsDir       = $cfg.LogsDir
$PsiRepackerExe= $cfg.PsiRepackerExe
$DotnetToolsDir= $cfg.DotnetToolsDir

# Ensure dotnet tools folder is on PATH
if ($env:PATH -notlike "*$DotnetToolsDir*") {
    $env:PATH += ";$DotnetToolsDir"
}

# ─────────────────────────────────────────────────────────────────────────────
#  Logging
# ─────────────────────────────────────────────────────────────────────────────
$RunTimestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
$LogFile      = Join-Path $LogsDir "BinaryCreator_$RunTimestamp.log"

function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowEmptyString()]
        [string]$Message,

        [ValidateSet('INFO', 'WARN', 'ERROR', 'SUCCESS')]
        [string]$Level = 'INFO'
    )
    process {
        $ts    = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        $entry = "[$ts] [$Level]  $Message"
        Add-Content -Path $LogFile -Value $entry

        switch ($Level) {
            'INFO'    { Write-Host $entry -ForegroundColor Cyan   }
            'WARN'    { Write-Host $entry -ForegroundColor Yellow }
            'ERROR'   { Write-Host $entry -ForegroundColor Red    }
            'SUCCESS' { Write-Host $entry -ForegroundColor Green  }
        }
    }
}

function Write-Step {
    param([string]$Title)
    $bar   = '─' * 64
    $block = "`n$bar`n  $Title`n$bar"
    Write-Host $block -ForegroundColor Magenta
    Add-Content -Path $LogFile -Value $block
}

function Format-Bytes {
    param([long]$Bytes)
    switch ($Bytes) {
        { $_ -ge 1GB } { return '{0:N2} GB' -f ($_ / 1GB) }
        { $_ -ge 1MB } { return '{0:N2} MB' -f ($_ / 1MB) }
        { $_ -ge 1KB } { return '{0:N2} KB' -f ($_ / 1KB) }
        default         { return "$_ B"                      }
    }
}

function Format-Elapsed {
    param([timespan]$ts)
    if ($ts.TotalHours -ge 1) { return '{0}h {1}m {2}s' -f [int]$ts.TotalHours, $ts.Minutes, $ts.Seconds }
    if ($ts.TotalMinutes -ge 1) { return '{0}m {1}s' -f [int]$ts.TotalMinutes, $ts.Seconds }
    return '{0}s' -f [int]$ts.TotalSeconds
}

# ─────────────────────────────────────────────────────────────────────────────
#  Validate prerequisites
# ─────────────────────────────────────────────────────────────────────────────
Write-Step 'Validating prerequisites'

$hibpExe = Get-Command 'haveibeenpwned-downloader.exe' -ErrorAction SilentlyContinue
if (-not $hibpExe) {
    Write-Log 'haveibeenpwned-downloader.exe not found on PATH.' -Level ERROR
    Write-Log "Ensure PrepareEnv.ps1 was run and '$DotnetToolsDir' is on PATH." -Level ERROR
    exit 1
}
Write-Log "haveibeenpwned-downloader : $($hibpExe.Source)" -Level SUCCESS

if (-not (Test-Path $PsiRepackerExe)) {
    Write-Log "PsiRepacker.exe not found at: $PsiRepackerExe" -Level ERROR
    Write-Log 'Please re-run PrepareEnv.ps1 to rebuild PsiRepacker.' -Level ERROR
    exit 1
}
Write-Log "PsiRepacker.exe           : $PsiRepackerExe" -Level SUCCESS

# ─────────────────────────────────────────────────────────────────────────────
#  File paths
# ─────────────────────────────────────────────────────────────────────────────
$DateSuffix   = Get-Date -Format 'ddMMyy'
$HashBaseName = 'pwnedpasswords_ntlm'       # downloader appends _ntlm itself
$HashFile     = Join-Path $HashesDir "${HashBaseName}.txt"
$BinFileName  = "hibpntlmhashes${DateSuffix}.bin"
$BinFile      = Join-Path $BinDir $BinFileName

Write-Log "Hash text file : $HashFile"
Write-Log "Binary output  : $BinFile"
Write-Log "Log file       : $LogFile"

# ─────────────────────────────────────────────────────────────────────────────
#  Step 1 – Download NTLM hashes
# ─────────────────────────────────────────────────────────────────────────────
Write-Step "Step 1/2 – Downloading NTLM hashes  (parallelism: $Parallelism)"

$dlElapsed = [timespan]::Zero

if ($SkipDownload -and (Test-Path $HashFile)) {
    $hashSize = (Get-Item $HashFile).Length
    Write-Log "-SkipDownload specified and hash file already exists – skipping download." -Level SUCCESS
    Write-Log "Hash file size : $(Format-Bytes $hashSize)  ($hashSize bytes)"
} else {
    if ($SkipDownload) {
        Write-Log '-SkipDownload specified but hash file not found – downloading anyway.' -Level WARN
    }

    $overwriteFlag = if ($NoOverwrite) { @() } else { @('-o') }
    $downloadArgs  = @('-n', $HashBaseName) + $overwriteFlag + @('-p', $Parallelism.ToString())
    $downloadCmd   = "haveibeenpwned-downloader.exe $($downloadArgs -join ' ')"

    Write-Log "Changing working directory to: $HashesDir"
    Write-Log "Executing: $downloadCmd"
    Write-Log ''

    $dlStart    = [datetime]::UtcNow
    $dlExitCode = 0

    Push-Location $HashesDir
    try {
        & haveibeenpwned-downloader.exe @downloadArgs 2>&1 | ForEach-Object {
            $line = $_.ToString()
            $ts   = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            Add-Content -Path $LogFile -Value "[$ts] [HIBP]   $line"
            Write-Host "  $line" -ForegroundColor DarkCyan
        }
        $dlExitCode = $LASTEXITCODE
    } finally {
        Pop-Location
    }

    $dlElapsed = [datetime]::UtcNow - $dlStart

    if ($dlExitCode -ne 0) {
        Write-Log "haveibeenpwned-downloader exited with code $dlExitCode." -Level ERROR
        exit $dlExitCode
    }

    if (-not (Test-Path $HashFile)) {
        Write-Log "Expected hash file not found after download: $HashFile" -Level ERROR
        Write-Log 'The downloader may have used a different output path. Check the hashes directory.' -Level WARN
        exit 1
    }

    $hashSize = (Get-Item $HashFile).Length
    Write-Log ''
    Write-Log "Download complete in $(Format-Elapsed $dlElapsed)." -Level SUCCESS
    Write-Log "Hash file size : $(Format-Bytes $hashSize)  ($hashSize bytes)" -Level SUCCESS
}

# ─────────────────────────────────────────────────────────────────────────────
#  Step 2 – Compress to binary with PsiRepacker
# ─────────────────────────────────────────────────────────────────────────────
Write-Step "Step 2/2 – Compressing to binary  ($BinFileName)"

Write-Log "Input  : $HashFile"
Write-Log "Output : $BinFile"
Write-Log "Tool   : $PsiRepackerExe"
Write-Log ''

$packStart  = [datetime]::UtcNow
$spinChars  = '|', '/', '-', '\'
$spinIdx    = 0

# Use temp files for stdout/stderr – avoids PowerShell runspace issues with
# async Process event handlers on background threads.
$tmpStdout = [System.IO.Path]::GetTempFileName()
$tmpStderr = [System.IO.Path]::GetTempFileName()

$proc = Start-Process -FilePath $PsiRepackerExe `
            -ArgumentList "`"$HashFile`" `"$BinFile`"" `
            -RedirectStandardOutput $tmpStdout `
            -RedirectStandardError  $tmpStderr `
            -NoNewWindow -PassThru

# Spinner loop – update every 250 ms while process runs
$cursorLeft = $Host.UI.RawUI.CursorPosition.X
$cursorTop  = $Host.UI.RawUI.CursorPosition.Y

while (-not $proc.HasExited) {
    $elapsed    = [datetime]::UtcNow - $packStart
    $outSize    = if (Test-Path $BinFile) { (Get-Item $BinFile).Length } else { 0 }
    $spinChar   = $spinChars[$spinIdx % $spinChars.Count]
    $spinIdx++
    $statusLine = "  [$spinChar]  Elapsed: $(Format-Elapsed $elapsed)   Output: $(Format-Bytes $outSize)   "
    try {
        $Host.UI.RawUI.CursorPosition = [System.Management.Automation.Host.Coordinates]::new($cursorLeft, $cursorTop)
        Write-Host $statusLine -NoNewline -ForegroundColor DarkYellow
    } catch {
        Write-Host $statusLine -ForegroundColor DarkYellow
    }
    Start-Sleep -Milliseconds 250
}

$proc.WaitForExit()
$packExitCode = $proc.ExitCode
$packElapsed  = [datetime]::UtcNow - $packStart

Write-Host (' ' * 80)

# Flush captured output to log
$stdoutLines = Get-Content $tmpStdout -ErrorAction SilentlyContinue
$stderrLines = Get-Content $tmpStderr -ErrorAction SilentlyContinue
Remove-Item $tmpStdout, $tmpStderr -ErrorAction SilentlyContinue

foreach ($line in $stdoutLines) {
    $ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Add-Content -Path $LogFile -Value "[$ts] [PSI]    $line"
    if ($line.Trim()) { Write-Host "  $line" -ForegroundColor DarkGray }
}
foreach ($line in $stderrLines) {
    $ts = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    Add-Content -Path $LogFile -Value "[$ts] [PSI-ERR] $line"
    if ($line.Trim()) { Write-Host "  $line" -ForegroundColor DarkRed }
}

if ($packExitCode -ne 0) {
    Write-Log "PsiRepacker exited with code $packExitCode." -Level ERROR
    exit $packExitCode
}

if (-not (Test-Path $BinFile)) {
    Write-Log "Expected binary not found after packing: $BinFile" -Level ERROR
    exit 1
}

$binSize = (Get-Item $BinFile).Length

# ─────────────────────────────────────────────────────────────────────────────
#  Summary
# ─────────────────────────────────────────────────────────────────────────────
Write-Step 'Completed'

Write-Log "Packing complete in $(Format-Elapsed $packElapsed)." -Level SUCCESS
Write-Log ''
Write-Log '  ┌─ Output ──────────────────────────────────────────────────────'
Write-Log "  │  File    : $BinFile"
Write-Log "  │  Size    : $(Format-Bytes $binSize)  ($binSize bytes)"
Write-Log "  │  Ratio   : $([math]::Round((1 - $binSize / $hashSize) * 100, 1))% reduction from source"
Write-Log '  └───────────────────────────────────────────────────────────────'
Write-Log ''
Write-Log "  Download time : $(Format-Elapsed $dlElapsed)"
Write-Log "  Pack time     : $(Format-Elapsed $packElapsed)"
Write-Log "  Total time    : $(Format-Elapsed ($dlElapsed + $packElapsed))"
Write-Log ''
Write-Log "  Log file      : $LogFile"
Write-Log '' -Level SUCCESS
Write-Log "Binary ready: $BinFile" -Level SUCCESS
